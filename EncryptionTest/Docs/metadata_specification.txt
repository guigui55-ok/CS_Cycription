AesEncryptor メタデータ仕様 (TLV バイナリ形式)
============================================

目的
- AES 暗号化ファイルに付与するメタデータを TLV（Tag-Length-Value）形式のバイナリで定義する。
- 攻撃者に有益な情報露出を抑えつつ、将来互換のための拡張性を確保する。

基本方針
- ファイル形式: TLV（バイナリ、可読性を下げることで難読化を兼ねる）
- 必要最小限のデータは含める（復号に必須な salt / iv 等）。
- `alg`、`itor` は可能ならファイルに書かず、コード内の定数で管理する（フォーマットバージョンで解釈）。
- `keylen`/`mode`/`padding`/`kdf`/`kdfHash` は冗長だが将来互換のために残す（TLV タグとして任意含有）。
- `filename` と `created` は情報漏洩リスクがあるため削除する。
- 改ざん検知 (`auth`) は将来互換のために残すが、現仕様では必須ではない。

ファイルヘッダ（先頭固定領域）
- 先頭 4 バイト: マジックバイト ASCII "AES1"
- 次 1 バイト: フォーマットバージョン（ver）例: 0x01
- 以降: TLV レコード列（任意順、Parser は未認識タグをスキップすること）

TLV フォーマット（レコード単位）
- Tag: 1 バイト
- Length: 2 バイト（UInt16、ネットワークバイトオーダー = Big-endian）
- Value: Length バイト

推奨 Tag 割当（変更禁止ではないがドキュメント化）
- 0x01 : salt
  - Value: 生バイト列
  - 推奨長: 16 バイト（実装はこの長さを期待）
- 0x02 : iv
  - Value: 生バイト列
  - AES ブロックサイズ: 16 バイト（CBC/PKCS7 の場合）
- 0x03 : keylen
  - Value: UInt16 (Big-endian)。例 256
- 0x04 : mode
  - Value: UTF-8 文字列（例 "CBC"）
- 0x05 : padding
  - Value: UTF-8 文字列（例 "PKCS7"）
- 0x06 : kdf
  - Value: UTF-8 文字列（例 "PBKDF2"）
- 0x07 : kdfHash
  - Value: UTF-8 文字列（例 "SHA-256"）
- 0x08 : auth
  - Value: 生バイト列（HMAC 等のタグ）。任意（将来追加を想定）
- 0x09 : reserved_for_itor
  - Value: UInt32 (Big-endian)（反復回数）。※可能ならコード内定数で管理するため通常は含めない
- 0x0A : reserved_for_alg
  - Value: UTF-8 文字列（例 "AES-CBC"）。※可能ならコード内定数で管理するため通常は含めない
- 0xFF : custom / vendor specific
  - Value: 任意バイナリ

TLV の取り扱い（実装ルール）
- Parser は未認識の Tag を無害にスキップすること（互換性確保）。
- Salt/IV は必ず含めること（復号に必須）。
- 数値は Big-endian でエンコードする（ネットワークオーダー）。
- バイナリ値（salt/iv/auth）はそのまま生バイト列として格納する（Base64 エンコードは不要、TLV がバイナリなので）。
- `alg` と `itor` をファイルに含めない場合は、ヘッダの `ver` によって実装側がアルゴリズム／パラメータを解釈すること。
  - 例: ver=1 → alg=AES-CBC、kdf=PBKDF2-HMAC-SHA256、itor=100000、keylen=256、mode=CBC、padding=PKCS7（これらはコード定数として保持）
- 将来フォーマット変更時は `ver` をインクリメントし、古い ver のパーサは適切に拒否または降格処理を行うこと。

セキュリティ勧告
- メタデータは最小限にし、運用情報（ファイル名や作成日時等）は含めない。
- salt と iv は RandomNumberGenerator で暗号学的に生成する（推奨長: 16 バイト）。
- 改ざん検知 (auth) の追加を検討する。可能であれば別 KDF 派生キーで HMAC を付与するか、将来的に AES-GCM 等の AEAD へ移行することを推奨。
- 仕様・定数（alg, itor 等）をバイナリ／ソース管理下に置くことで、ファイル単体の解析で得られる情報を最小化する。だがソース/バイナリが漏洩した場合は無効である点に留意する。

例（構築例の擬似手順）
1. 出力ファイル先に "AES1" + ver(1)
2. salt (Tag=0x01, Length=0x0010, Value=16 bytes)
3. iv   (Tag=0x02, Length=0x0010, Value=16 bytes)
4. (任意) keylen/mode/padding/kdf/kdfHash を必要に応じて付与
5. ciphertext をファイル末尾に連結（TLV レコード列の後に配置）

注記
- この TLV 仕様は「可読性を下げる」ことを目的とした設計であり、セキュリティは暗号設計（強 KDF、ランダム salt/iv、長い鍵）に依存する。TLV 自体は秘匿手段ではない。
- 仕様変更時は必ず `ver` と本ファイルを更新すること。